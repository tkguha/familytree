<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Family Lineage Tree</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root{
      --accent:#2196f3;
      --box-bg:#eaf4ff;
      --box-border:#1e88e5;
      --text:#111;
      --badge-bg:#0b76d1;
      --badge-color:#fff;
    }
    body{
      margin:0;
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      background:#f5f8fb;
      overflow:hidden;
    }

    header{
      background:var(--accent);
      color:white;
      padding:12px 16px;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:12px;
      box-shadow:0 2px 6px rgba(0,0,0,0.12);
      position:relative;
      z-index:50;
    }
    header h1{ margin:0; font-size:20px; letter-spacing:0.3px; font-weight:600; }

    /* Info box (collapsible) */
    #info-wrapper{ position:absolute; top:12px; right:12px; z-index:60; }
    #info-toggle{
      background:white; border-radius:8px; padding:6px 8px; border:1px solid #ddd; cursor:pointer;
      box-shadow:0 1px 3px rgba(0,0,0,0.08);
      display:flex; gap:8px; align-items:center;
    }
    #info-content{
      margin-top:8px; width:320px; background:#fff; border-radius:10px; padding:12px;
      box-shadow:0 6px 18px rgba(0,0,0,0.08); border:1px solid #e6e6e6;
      font-size:13px; color:#333; line-height:1.4;
    }
    #info-content.hidden{ display:none; }

    /* Search box */
    #controls{ position:absolute; left:16px; top:12px; z-index:60; display:flex; gap:8px; align-items:center;}
    #search{
      width:260px; padding:8px 10px; border-radius:8px; border:1px solid #ccc; font-size:13px;
      box-shadow:0 1px 3px rgba(0,0,0,0.06);
    }
    #suggestions{ position:absolute; left:16px; top:52px; z-index:70; background:#fff; border-radius:6px; box-shadow:0 6px 18px rgba(0,0,0,0.12); max-height:220px; overflow:auto; width:260px; display:none; }
    #suggestions div{ padding:8px 10px; cursor:pointer; border-bottom:1px solid #f0f0f0; }
    #suggestions div:hover{ background:#f0f6ff; }

    /* Footer */
    footer{
      position:absolute; bottom:8px; left:0; right:0; text-align:center; font-size:13px; color:#555; z-index:50;
    }
    footer a{ color:var(--accent); text-decoration:none; font-weight:600; cursor:pointer; }

    /* SVG */
    svg{ width:100%; height:calc(100vh - 56px); cursor:grab; background:linear-gradient(180deg,#fbfdff, #f5f8fb); }

    .link{ fill:none; stroke:#bfcfdc; stroke-width:2px; }
    .node text{ font-size:14px; fill:var(--text); pointer-events:none; }
    .node rect{ fill:var(--box-bg); stroke:var(--box-border); stroke-width:1.6px; rx:10; ry:10; }
    .badge{
      fill:var(--badge-bg); opacity:0.95; stroke:none;
    }
    .badge-text{ fill:var(--badge-color); font-size:11px; font-weight:600; text-anchor:middle; dominant-baseline:central; pointer-events:none; }
    .leaf-dot{ fill:#e53935; } /* red dot to mark leaf */

    /* Highlighting */
    .highlight rect{ stroke:#ff8a65; stroke-width:2.5px; filter: drop-shadow(0 2px 6px rgba(255,140,105,0.25)); }
    .faded{ opacity:0.25; }

    /* small helper */
    .gen-label{ font-size:12px; fill:#444; pointer-events:none; }
  </style>
</head>
<body>

  <header><h1>Family Lineage Tree</h1></header>

  <div id="controls">
    <input id="search" placeholder="Search name..." autocomplete="off"/>
    <div id="suggestions"></div>
  </div>

  <div id="info-wrapper" aria-hidden="false">
    <div id="info-toggle" title="Toggle info">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z" stroke="#2196f3" stroke-width="1.4" fill="none"/><path d="M12 8v6" stroke="#2196f3" stroke-width="1.6" stroke-linecap="round"/><circle cx="12" cy="17" r="0.8" fill="#2196f3"/></svg>
      <div style="font-size:13px;color:#222">Info</div>
    </div>
    <div id="info-content">
      <strong>About this tree</strong>
      <p style="margin:8px 0 0 0;">
        Click any box to expand/collapse. Use mouse wheel (or pinch) to zoom and drag to pan. The tree data is fetched from a shared Google Sheet (public CSV).
      </p>
      <p style="margin:8px 0 0 0;font-size:12px;color:#666;">
        Use the search box to quickly find a person — suggestions appear as you type.
      </p>
    </div>
  </div>

  <svg></svg>

  <footer>
    <span>Designed by <a id="footer-link">TAMAL KUMAR GUHA</a> © 2025</span>
  </footer>

<script>
/* ================= CONFIG ================== */
const csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTxk4d1BIyeRjHKnaPh_D2SgbpxqjPNnck4sz3PSpocQKgkl2A54-v92UT09ov-x1ibJNgLaSrBgdsX/pub?gid=0&single=true&output=csv";
const FOOTER_TARGET_NAME = "Tamal"; // will search names containing this substring (case-insensitive)
/* ========================================== */

/* basic svg setup */
const svg = d3.select("svg");
const g = svg.append("g");
const width = window.innerWidth;
const height = window.innerHeight - 56; // header height approx
let currentHighlighted = null;

/* zoom/pan */
const zoom = d3.zoom().scaleExtent([0.25, 2.5]).on("zoom", (event) => g.attr("transform", event.transform));
svg.call(zoom);

/* tree layout */
const tree = d3.tree().nodeSize([70, 260]);
const duration = 450;

/* data holders */
let root; // d3 hierarchy
let flatList = []; // array of nodes for search

/* Load data and build tree */
d3.csv(csvUrl).then(rows => {
  // Normalize keys: expect ID, Name, ParentID, PhotoURL, Details
  rows = rows.map(r => ({
    ID: (r.ID||r.id||"").toString().trim(),
    Name: (r.Name||r.name||"").toString().trim(),
    ParentID: (r.ParentID||r.ParentId||r.parentid||"").toString().trim(),
    PhotoURL: (r.PhotoURL||r.photoURL||r.photo||"").toString().trim(),
    Details: (r.Details||r.details||"").toString().trim()
  }));

  // Build lookup and tree
  const map = {};
  rows.forEach(r => map[r.ID] = {...r, children: []});
  let top = null;
  rows.forEach(r => {
    if (r.ParentID && map[r.ParentID]) map[r.ParentID].children.push(map[r.ID]);
    else top = map[r.ID] || top || map[r.ID];
  });
  if (!top) top = rows.length ? map[rows[0].ID] : null;

  root = d3.hierarchy(top, d => d.children && d.children.length ? d.children : null);
  // compute descendant counts (recursive)
  computeDescCounts(root);

  // store flat list for search (name + id)
  flatList = [];
  root.each(d => flatList.push({ id: d.data.ID, name: d.data.Name, node: d }));

  // collapse all children initially
  if (root.children) root.children.forEach(collapse);
  root.x0 = 0; root.y0 = 0;
  update(root);

  // Center initial view
  svg.call(zoom.transform, d3.zoomIdentity.translate(window.innerWidth/2 - 120, 120).scale(0.85));
});

/* compute descendants (excluding self), attach count on data */
function computeDescCounts(node){
  let total = 0;
  if (node.children){
    node.children.forEach(ch => {
      computeDescCounts(ch);
      total += 1 + (ch.data._descCount || 0);
    });
  }
  node.data._descCount = total;
}

/* collapsing helper */
function collapse(d){
  if (d.children){
    d._children = d.children;
    d._children.forEach(collapse);
    d.children = null;
  }
}

/* update visualization */
function update(source){
  const treeData = tree(root);
  const nodes = treeData.descendants();
  const links = treeData.links();

  // depth spacing
  nodes.forEach(d => d.y = d.depth * 260);

  // NODES: bind
  const nodeSel = g.selectAll("g.node").data(nodes, d => d.data.ID);

  // ENTER
  const nodeEnter = nodeSel.enter().append("g")
    .attr("class","node")
    .attr("transform", d => `translate(${source.y0},${source.x0})`)
    .on("click", (evt,d) => {
      if (d.children){ d._children = d.children; d.children = null; }
      else { d.children = d._children; d._children = null; }
      update(d);
    });

  // append text (multi-line) placeholder; we'll measure it to create dynamic rect
  nodeEnter.append("text")
    .attr("class","node-label")
    .attr("dy","0")
    .attr("text-anchor","middle")
    .text(d => d.data.Name)
    .each(function(d){
      // wrap text into tspan lines (simple greedy wrap)
      const text = d3.select(this);
      const words = d.data.Name.split(/\s+/);
      const lineHeight = 1.1;
      const maxChars = 24; // approximate wrap fallback
      let line = [], lineNumber = 0;
      text.text(null);
      let tspan = text.append("tspan").attr("x",0).attr("y",0).attr("dy","0em");
      words.forEach(w => {
        line.push(w);
        tspan.text(line.join(" "));
        if (tspan.node().getComputedTextLength() > 140){ // temporary width guess
          line.pop();
          tspan.text(line.join(" "));
          line = [w];
          tspan = text.append("tspan").attr("x",0).attr("y",0).attr("dy",++lineNumber * lineHeight + "em").text(w);
        }
      });
    });

  // After text is created, measure bounding box and insert rect below text
  nodeEnter.each(function(d){
    const nodeG = d3.select(this);
    const textEl = nodeG.select("text").node();
    const bbox = textEl.getBBox();
    const padX = 12, padY = 8;
    const rectW = Math.max(80, bbox.width + padX*2);
    const rectH = bbox.height + padY*2;

    // store dimensions on d for later positioning (used for gen label)
    d._rectW = rectW; d._rectH = rectH;

    nodeG.insert("rect","text")
      .attr("x", -rectW/2)
      .attr("y", -rectH/2)
      .attr("width", rectW)
      .attr("height", rectH)
      .attr("rx", 10).attr("ry", 10)
      .style("fill", "var(--box-bg)")
      .style("stroke", "var(--box-border)")
      .style("stroke-width", 1.6);

    // reposition text vertically centered
    nodeG.select("text")
      .attr("y", - (rectH/2) + padY + 2)
      .attr("text-anchor","middle");

    // Add descendant badge at top-right of rect
    const descCount = d.data._descCount || 0;
    if (descCount > 0){
      const bx = rectW/2 - 12;
      const by = -rectH/2 + 10;
      nodeG.append("circle").attr("class","badge").attr("cx",bx).attr("cy",by).attr("r",12);
      nodeG.append("text").attr("class","badge-text").attr("x",bx).attr("y",by).text(descCount);
    }

    // Add generation label just under rect
    const genLabelY = rectH/2 + 14;
    nodeG.append("text").attr("class","gen-label").attr("y", genLabelY).attr("text-anchor","middle").text(`Gen ${d.depth+1}`);

    // If leaf node (no children/_children), add red dot to right
    const isLeaf = !(d.children || d._children);
    if (isLeaf){
      const dx = rectW/2 + 12;
      nodeG.append("circle").attr("class","leaf-dot").attr("cx", dx).attr("cy", 0).attr("r",6);
    }
  });

  // UPDATE + Merge
  const nodeUpdate = nodeEnter.merge(nodeSel);
  nodeUpdate.transition().duration(duration).attr("transform", d => `translate(${d.y},${d.x})`);

  // exit
  const nodeExit = nodeSel.exit().transition().duration(duration)
    .attr("transform", d => `translate(${source.y},${source.x})`).remove();

  // LINKS
  const linkSel = g.selectAll("path.link").data(links, d => d.target.data.ID);
  const linkEnter = linkSel.enter().insert("path","g").attr("class","link")
    .attr("d", d => {
      const o = {x: source.x0, y: source.y0};
      return diagonal(o,o);
    });
  linkEnter.merge(linkSel).transition().duration(duration).attr("d", d => diagonal(d.source, d.target));
  linkSel.exit().transition().duration(duration).remove();

  // save positions for transitions
  nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
}

/* curved link path */
function diagonal(s, d){
  return `M ${s.y} ${s.x}
          C ${(s.y + d.y)/2} ${s.x},
            ${(s.y + d.y)/2} ${d.x},
            ${d.y} ${d.x}`;
}

/* ===== Search & highlight functions ===== */
const searchInput = document.getElementById('search');
const suggestionsBox = document.getElementById('suggestions');
let suggestionVisible = false;

/* update suggestion list */
function showSuggestions(filtered){
  suggestionsBox.innerHTML = '';
  if (!filtered.length){ suggestionsBox.style.display='none'; suggestionVisible=false; return; }
  filtered.slice(0,30).forEach(item => {
    const div = document.createElement('div');
    div.textContent = item.name;
    div.onclick = () => { selectSearchResult(item); suggestionsBox.style.display='none'; suggestionVisible=false; };
    suggestionsBox.appendChild(div);
  });
  suggestionsBox.style.display='block'; suggestionVisible=true;
}

/* input handler */
searchInput.addEventListener('input', e => {
  const q = e.target.value.trim().toLowerCase();
  if (!q){ showSuggestions([]); return; }
  const results = flatList.filter(x => x.name.toLowerCase().includes(q));
  showSuggestions(results);
});

/* keyboard handling */
searchInput.addEventListener('keydown', e => {
  if (e.key === 'Enter'){ 
    const q = e.target.value.trim().toLowerCase();
    if (!q) return;
    const exact = flatList.find(x => x.name.toLowerCase() === q);
    if (exact) selectSearchResult(exact);
    else {
      const first = flatList.find(x => x.name.toLowerCase().includes(q));
      if (first) selectSearchResult(first);
    }
    suggestionsBox.style.display='none'; suggestionVisible=false;
  }
});

/* click outside to hide suggestions */
window.addEventListener('click', (e) => {
  if (!document.getElementById('controls').contains(e.target) && suggestionVisible){
    suggestionsBox.style.display='none'; suggestionVisible=false;
  }
});

/* selecting a search result: expand parents, center & highlight */
function selectSearchResult(item){
  if (!item || !item.node) return;
  expandPathTo(item.node);
  centerOnNode(item.node);
  highlightNode(item.node);
}

/* Expand parents so the path to target node is visible */
function expandPathTo(targetNode){
  let curr = targetNode.parent;
  const toExpand = [];
  while(curr){
    toExpand.push(curr);
    curr = curr.parent;
  }
  // expand from top to bottom
  toExpand.reverse().forEach(n => {
    if (n._children){ n.children = n._children; n._children = null; }
  });
  update(targetNode);
}

/* center and zoom to a node */
function centerOnNode(targetNode){
  const transform = d3.zoomTransform(svg.node());
  const x = targetNode.x, y = targetNode.y;
  const scale = Math.max(.5, Math.min(1.5, transform.k));
  const translateX = window.innerWidth/2 - y*scale;
  const translateY = (window.innerHeight - 56)/2 - x*scale;
  svg.transition().duration(700).call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
}

/* highlight node temporarily */
function highlightNode(d){
  // clear previous
  g.selectAll("g.node").classed("highlight", false).classed("faded", false);
  // fade others
  g.selectAll("g.node").filter(n=> n.data.ID !== d.data.ID).classed("faded", true);
  // highlight target
  const targetG = g.selectAll("g.node").filter(n=> n.data.ID === d.data.ID);
  targetG.classed("highlight", true);
  // scroll back to normal after a while (remove faded on click elsewhere)
  clearTimeout(window._highlightTimer);
  window._highlightTimer = setTimeout(()=> { g.selectAll("g.node").classed("highlight", false).classed("faded", false); }, 7000);
}

/* ===== Footer link behavior (expand parents then center & highlight) ===== */
document.getElementById('footer-link').addEventListener('click', () => {
  // find node with name containing FOOTER_TARGET_NAME (case-insensitive)
  const found = flatList.find(x => x.name.toLowerCase().includes(FOOTER_TARGET_NAME.toLowerCase()));
  if (!found){ alert("Could not find 'Tamal' in the sheet. Ensure the Name contains 'Tamal'."); return; }
  selectSearchResult(found);
});

/* ===== info box toggle ===== */
const infoToggle = document.getElementById('info-toggle');
const infoContent = document.getElementById('info-content');
let infoOpen = true;
infoToggle.addEventListener('click', () => {
  infoOpen = !infoOpen;
  if (infoOpen){ infoContent.classList.remove('hidden'); } else { infoContent.classList.add('hidden'); }
});

/* ===== window resize: keep view reasonable ===== */
window.addEventListener('resize', () => {
  // maintain transform roughly centered
  // optional: re-center to root
});
</script>
</body>
</html>

