<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Guha Family Lineage Tree</title>

<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
  :root{
    --accent:#215f9b;
    --box-bg:#fffdf8;
    --box-border:#b08b57;
    --text:#1b2733;
    --badge-bg:#0b76d1;
    --badge-color:#fff;
  }

  /* Very subtle aged parchment (P2, T1 intensity) */
  body{
    margin:0;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background-color:#fbf6ee;
    /* subtle parchment texture using tiny SVG data URI */
    background-image:
      linear-gradient(180deg, rgba(255,255,255,0.6), rgba(244,238,226,0.4)),
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 60 60'%3E%3Cg fill='%23f6efe6' fill-opacity='0.6'%3E%3Crect width='60' height='60'/%3E%3Cpath d='M0 0h10v10H0zM30 30h10v10H30z'/%3E%3C/g%3E%3C/svg%3E");
    background-repeat:repeat;
    background-size: 260px 260px;
    overflow:hidden;
    color:var(--text);
  }

  /* Fixed header */
  header{
    position:fixed; top:0; left:0; right:0;
    height:56px; display:flex; align-items:center; gap:12px;
    padding:8px 14px; z-index:120;
    background: rgba(255,255,250,0.85);
    box-shadow: 0 3px 12px rgba(16,24,40,0.06);
    backdrop-filter: blur(4px);
  }
  header h1{ margin:0; font-size:18px; color:var(--accent); font-weight:700; }

  /* search */
  #controls{ margin-left:12px; display:flex; align-items:center; gap:8px; }
  #search{ padding:8px 10px; width:260px; border-radius:8px; border:1px solid rgba(0,0,0,0.12); background:white; font-size:14px; }
  #suggestions{ position:absolute; left:14px; top:60px; width:260px; display:none; max-height:220px; overflow:auto; background:white; border-radius:8px; box-shadow:0 8px 24px rgba(16,24,40,0.08); z-index:130; }

  #suggestions div{ padding:8px 10px; border-bottom:1px solid #f0f0f0; cursor:pointer; }
  #suggestions div:hover{ background:#f2f8ff; }

  /* Info box fixed top-right */
  #info-wrapper{ position:fixed; top:8px; right:14px; z-index:130; display:flex; flex-direction:column; align-items:flex-end; }
  #info-toggle{ display:flex; align-items:center; gap:8px; padding:6px 8px; background:white; border-radius:8px; border:1px solid rgba(0,0,0,0.06); cursor:pointer; box-shadow:0 6px 18px rgba(16,24,40,0.06); }
  #info-content{ margin-top:8px; width:320px; background:rgba(255,255,255,0.98); border-radius:10px; padding:12px; font-size:13px; box-shadow:0 12px 30px rgba(16,24,40,0.06); }
  #info-content.hidden{ display:none; }

  /* SVG area below header */
  #svgwrap{ position:absolute; top:64px; left:0; right:0; bottom:48px; overflow:hidden; }
  svg{ width:100%; height:100%; display:block; }

  /* node visuals (we use <g> with rect and text and optional image) */
  .link{ fill:none; stroke:#cfc6b6; stroke-width:2px; }
  .node text { font-size:13px; fill:var(--text); pointer-events:none; }
  .node rect { fill:var(--box-bg); stroke:var(--box-border); stroke-width:1.4px; rx:10; ry:10; filter: drop-shadow(0 4px 10px rgba(16,24,40,0.06)); }
  .badge{ fill:var(--badge-bg); }
  .badge-text{ fill:var(--badge-color); font-size:11px; font-weight:700; text-anchor:middle; dominant-baseline:central; pointer-events:none; }
  .leaf-dot{ fill:#e53935; }

  .highlight rect{ stroke:#ff8a65; stroke-width:2.6px; filter: drop-shadow(0 8px 18px rgba(255,134,94,0.15)); }
  .faded{ opacity:0.18; }

  .gen-label{ font-size:12px; fill:#5b6b78; pointer-events:none; }

  /* photo circle */
  image.photo{ width:56px; height:56px; border-radius:50%; }

  /* footer */
  footer{ position:fixed; left:0; right:0; bottom:6px; z-index:120; text-align:center; }
  #footer-button{ display:inline-block; background:#fff; padding:8px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); cursor:pointer; box-shadow:0 6px 18px rgba(16,24,40,0.06); color:var(--accent); font-weight:700; }

  /* responsive tweaks */
  @media (max-width:800px){
    #search{ width:160px; }
    #info-content{ width:220px; }
  }
</style>
</head>
<body>

<header>
  <h1>Guha Family Lineage Tree</h1>
  <div id="controls">
    <input id="search" type="search" placeholder="Search name..." autocomplete="off">
    <div id="suggestions" role="listbox"></div>
  </div>
</header>

<div id="info-wrapper">
  <div id="info-toggle" title="Toggle info">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10" stroke="#215f9b" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M12 8v6" stroke="#215f9b" stroke-width="1.6" stroke-linecap="round"/><circle cx="12" cy="17" r="0.8" fill="#215f9b"/></svg>
    <div style="font-size:13px;color:#213">Info</div>
  </div>
  <div id="info-content">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <strong>About this tree</strong>
      <button id="info-close" style="background:#f6f7f8;border:0;padding:6px 8px;border-radius:8px;cursor:pointer;">Hide</button>
    </div>
    <p style="margin:8px 0 0 0;color:#334e68;">Click a box to reveal its immediate children (one generation at a time). Use mouse wheel (or pinch) to zoom and drag to pan.</p>
    <p style="margin:8px 0 0 0;font-size:12px;color:#596b78;">Data: <code>data/family.csv</code>. Optional images taken from <code>PhotoURL</code> column.</p>
  </div>
</div>

<div id="svgwrap"><svg></svg></div>

<footer><span id="footer-button">TAMAL KUMAR GUHA — Jump to my node</span></footer>

<script>
/* ----------------- CONFIG ----------------- */
const csvPath = "data/family.csv";
const FOOTER_TARGET_NAME = "Tamal"; // substring match
const PHOTO_SIZE = 56; // px circle badge
/* ------------------------------------------ */

const svg = d3.select("svg");
const wrap = d3.select("#svgwrap");
const g = svg.append("g").attr("transform","translate(0,0)");

const zoom = d3.zoom().scaleExtent([0.25, 2.2]).on("zoom", (event)=> g.attr("transform", event.transform));
svg.call(zoom);

const treeLayout = d3.tree().nodeSize([90, 300]);
const duration = 420;

let root = null;
let allNodes = []; // flat list for search

/* load local CSV */
fetch(csvPath)
  .then(res => {
    if(!res.ok) throw new Error("Failed to fetch " + csvPath + " (status " + res.status + ")");
    return res.text();
  })
  .then(txt => {
    const rows = d3.csvParse(txt);
    if(!rows || !rows.length) throw new Error("CSV parsed empty or invalid");
    buildHierarchy(rows);
  })
  .catch(err => {
    console.error("Error loading CSV:", err);
    alert("Error loading data/family.csv — check that file exists in /data and is published to repo. See console for details.");
  });

/* Build hierarchy + initial collapse to only gen 1 & 2 */
function buildHierarchy(rows){
  // normalize
  const normalized = rows.map(r => ({
    ID: (r.ID||r.id||"").toString().trim(),
    Name: (r.Name||r.name||"").toString().trim(),
    ParentID: (r.ParentID||r.parentid||r.ParentId||"").toString().trim(),
    PhotoURL: (r.PhotoURL||r.photoURL||r.photo||"").toString().trim(),
    Details: (r.Details||r.details||"").toString().trim()
  }));

  // map and attach children
  const map = {};
  normalized.forEach(r => { map[r.ID] = {...r, children: []}; });
  let rootObj = null;
  normalized.forEach(r => {
    if(r.ParentID && map[r.ParentID]) {
      map[r.ParentID].children.push(map[r.ID]);
    } else {
      if(!rootObj) rootObj = map[r.ID];
    }
  });
  if(!rootObj) rootObj = normalized.length ? map[normalized[0].ID] : null;
  if(!rootObj) { alert("No root found in CSV"); return; }

  root = d3.hierarchy(rootObj, d => d.children && d.children.length ? d.children : null);

  // compute descendant counts
  computeDesc(root);

  // collapse nodes deeper than depth 1 (so only Gen1 and Gen2 visible)
  root.each(d => {
    if(d.depth > 1) {
      if(d.children){ d._children = d.children; d.children = null; }
    }
  });

  // build flatList
  allNodes = [];
  root.each(d => allNodes.push({id:d.data.ID, name:d.data.Name, node:d}));

  // initial render
  update(root);

  // auto-center to root
  setTimeout(()=> centerOnNode(root, 0.9), 300);
}

/* compute descendant counts and annotate on data */
function computeDesc(node){
  let total = 0;
  if(node.children) node.children.forEach(ch => { computeDesc(ch); total += 1 + (ch.data._descCount||0); });
  if(node._children) node._children.forEach(ch => { computeDesc(ch); total += 1 + (ch.data._descCount||0); });
  node.data._descCount = total;
}

/* collapse helper */
function collapse(d){
  if(d.children){ d._children = d.children; d._children.forEach(collapse); d.children = null; }
}

/* update/render function */
function update(source){
  const treeData = treeLayout(root);
  const nodes = treeData.descendants();
  const links = treeData.links();

  // normalize depth spacing
  nodes.forEach(d => d.y = d.depth * 300);

  // LINKS
  const link = g.selectAll("path.link").data(links, d => d.target.data.ID);
  const linkEnter = link.enter().insert("path","g").attr("class","link")
    .attr("d", d => {
      const o = {x: source.x0 || source.x, y: source.y0 || source.y};
      return diagonal(o,o);
    });
  linkEnter.merge(link).transition().duration(duration).attr("d", d => diagonal(d.source, d.target));
  link.exit().transition().duration(duration).remove();

  // NODES
  const node = g.selectAll("g.node").data(nodes, d => d.data.ID);

  const nodeEnter = node.enter().append("g")
    .attr("class","node")
    .attr("transform", d => `translate(${source.y0 || source.y || 0},${source.x0 || source.x || 0})`)
    .on("click", (event,d) => {
      // Expansion Mode C: toggle only immediate children visibility (already implemented by children/_children)
      if(d.children){ d._children = d.children; d.children = null; }
      else { d.children = d._children; d._children = null; }
      // After toggling, recompute desc counts for visual correctness (optional)
      computeDesc(root);
      update(d);
      // center on the clicked node (optional)
      centerOnNode(d);
    });

  // add text placeholder to measure and allow wrapping
  nodeEnter.append("text")
    .attr("class","node-label")
    .attr("text-anchor","middle")
    .attr("dy","0")
    .text(d => d.data.Name)
    .each(function(d){
      // simple greedy wrap into tspans using width limit
      const text = d3.select(this);
      const words = d.data.Name.split(/\s+/);
      text.text(null);
      let line = [];
      let lineNumber = 0;
      const maxWidth = 160;
      let tspan = text.append("tspan").attr("x",0).attr("y",0).attr("dy","0em");
      words.forEach(w => {
        line.push(w);
        tspan.text(line.join(" "));
        if(tspan.node().getComputedTextLength() > maxWidth){
          line.pop();
          tspan.text(line.join(" "));
          line = [w];
          tspan = text.append("tspan").attr("x",0).attr("y",0).attr("dy",++lineNumber * 1.1 + "em").text(w);
        }
      });
    });

  // after text created, measure and create rect, optional photo, badges, generation label, leaf dot
  nodeEnter.each(function(d){
    const nodeG = d3.select(this);
    const textEl = nodeG.select("text").node();
    const bbox = textEl.getBBox();
    const padX = 12, padY = 8;
    const hasPhoto = !!(d.data.PhotoURL && d.data.PhotoURL.trim());
    const photoSpace = hasPhoto ? (PHOTO_SIZE + 8) : 0;
    const rectW = Math.max(90, bbox.width + padX*2);
    const rectH = bbox.height + padY*2 + photoSpace;
    d._rectW = rectW; d._rectH = rectH;

    // rect behind
    nodeG.insert("rect","text")
      .attr("x", -rectW/2)
      .attr("y", -rectH/2)
      .attr("width", rectW)
      .attr("height", rectH)
      .attr("rx",10).attr("ry",10)
      .style("fill", "var(--box-bg)")
      .style("stroke", "var(--box-border)")
      .style("stroke-width", 1.2);

    // photo (I1: round badge above name) - only if PhotoURL exists
    if(hasPhoto){
      const photoX = 0;
      const photoY = -rectH/2 + (PHOTO_SIZE/2) + 8;
      // unique clipPath id
      const clipId = "clip_" + (d.data.ID || Math.random()).replace(/[^a-zA-Z0-9_]/g,'_');
      // defs clip
      nodeG.append("clipPath").attr("id", clipId).append("circle")
        .attr("cx", photoX).attr("cy", photoY).attr("r", PHOTO_SIZE/2);
      nodeG.append("image")
        .attr("xlink:href", d.data.PhotoURL)
        .attr("x", photoX - PHOTO_SIZE/2)
        .attr("y", photoY - PHOTO_SIZE/2)
        .attr("width", PHOTO_SIZE)
        .attr("height", PHOTO_SIZE)
        .attr("class","photo")
        .attr("clip-path", `url(#${clipId})`);
    }

    // reposition text (below photo if present)
    if(hasPhoto) nodeG.select("text").attr("y", -rectH/2 + PHOTO_SIZE + padY + 6);
    else nodeG.select("text").attr("y", -rectH/2 + padY + 2);

    // descendant badge (top-right)
    const desc = d.data._descCount || 0;
    if(desc > 0){
      const bx = rectW/2 - 14;
      const by = -rectH/2 + 14;
      nodeG.append("circle").attr("class","badge").attr("cx",bx).attr("cy",by).attr("r",12);
      nodeG.append("text").attr("class","badge-text").attr("x",bx).attr("y",by).text(desc);
    }

    // generation label under rect
    const genY = rectH/2 + 14;
    nodeG.append("text").attr("class","gen-label").attr("y", genY).attr("text-anchor","middle").text(`Gen ${d.depth+1}`);

    // leaf red dot to right if leaf (no children and no _children)
    const isLeaf = !(d.children || d._children);
    if(isLeaf){
      const dx = rectW/2 + 12;
      nodeG.append("circle").attr("class","leaf-dot").attr("cx", dx).attr("cy", 0).attr("r",6);
    }
  });

  // MERGE + TRANSITION
  const nodeUpdate = nodeEnter.merge(node);
  nodeUpdate.transition().duration(duration).attr("transform", d => `translate(${d.y},${d.x})`);

  // EXIT
  const nodeExit = node.exit().transition().duration(duration).attr("transform", d => `translate(${source.y},${source.x})`).remove();

  // store positions
  nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
}

/* curved link path */
function diagonal(s,d){
  return `M ${s.y} ${s.x}
          C ${(s.y + d.y)/2} ${s.x},
            ${(s.y + d.y)/2} ${d.x},
            ${d.y} ${d.x}`;
}

/* --------- Search UI --------- */
const searchInput = document.getElementById('search');
const suggestionsBox = document.getElementById('suggestions');
let suggestionVisible = false;

function showSuggestions(list){
  suggestionsBox.innerHTML='';
  if(!list.length){ suggestionsBox.style.display='none'; suggestionVisible=false; return; }
  list.slice(0,30).forEach(item => {
    const div = document.createElement('div');
    div.textContent = item.name;
    div.onclick = () => { selectSearch(item); suggestionsBox.style.display='none'; suggestionVisible=false; };
    suggestionsBox.appendChild(div);
  });
  suggestionsBox.style.display='block'; suggestionVisible=true;
}

searchInput.addEventListener('input', e => {
  const q = e.target.value.trim().toLowerCase();
  if(!q){ showSuggestions([]); return; }
  const res = allNodes.filter(x => x.name.toLowerCase().includes(q));
  showSuggestions(res);
});

searchInput.addEventListener('keydown', e => {
  if(e.key === 'Enter'){
    const q = e.target.value.trim().toLowerCase();
    if(!q) return;
    const exact = allNodes.find(x => x.name.toLowerCase() === q) || allNodes.find(x => x.name.toLowerCase().includes(q));
    if(exact) selectSearch(exact);
    suggestionsBox.style.display='none'; suggestionVisible=false;
  }
});

window.addEventListener('click', (ev) => {
  if(!document.getElementById('controls')?.contains(ev.target) && suggestionVisible){
    suggestionsBox.style.display='none'; suggestionVisible=false;
  }
});

/* select result: expand parents, center, highlight */
function selectSearch(item){
  if(!item || !item.node) return;
  expandPathTo(item.node);
  centerOnNode(item.node);
  highlightNode(item.node);
}

/* expand parents (make path visible) */
function expandPathTo(target){
  let cur = target.parent;
  const toExpand = [];
  while(cur){
    toExpand.push(cur);
    cur = cur.parent;
  }
  toExpand.reverse().forEach(n => { if(n._children){ n.children = n._children; n._children = null; } });
  update(target);
}

/* center on node with reasonable scale */
function centerOnNode(node, preferScale=1.0){
  const svgRect = svg.node().getBoundingClientRect();
  const viewW = svgRect.width, viewH = svgRect.height;
  const transform = d3.zoomTransform(svg.node());
  const x = node.x, y = node.y;
  // preferScale from caller; limit within zoom extents
  const k = Math.max(0.45, Math.min(1.4, preferScale));
  const tx = viewW/2 - y*k;
  const ty = viewH/2 - x*k;
  svg.transition().duration(700).call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(k));
}

/* highlight a node */
function highlightNode(d){
  g.selectAll("g.node").classed("highlight", false).classed("faded", false);
  g.selectAll("g.node").filter(n => n.data.ID !== d.data.ID).classed("faded", true);
  g.selectAll("g.node").filter(n => n.data.ID === d.data.ID).classed("highlight", true);
  clearTimeout(window._highlightTimer);
  window._highlightTimer = setTimeout(()=> { g.selectAll("g.node").classed("highlight", false).classed("faded", false); }, 7000);
}

/* footer jump-to behavior (Option B: expand parents then center + highlight) */
document.getElementById('footer-button').addEventListener('click', () => {
  if(!allNodes.length){ alert("Data not yet loaded."); return; }
  const found = allNodes.find(x => x.name.toLowerCase().includes(FOOTER_TARGET_NAME.toLowerCase()));
  if(!found){ alert("Could not find 'Tamal' in data."); return; }
  selectSearch(found);
});

/* info box toggle */
const infoToggle = document.getElementById('info-toggle');
const infoContent = document.getElementById('info-content');
const infoClose = document.getElementById('info-close');
let infoOpen = true;
infoToggle.addEventListener('click', ()=> { infoOpen = !infoOpen; infoContent.classList.toggle('hidden', !infoOpen); });
infoClose.addEventListener('click', ()=> { infoOpen = false; infoContent.classList.add('hidden'); });

/* window resize: optional re-center on root */
window.addEventListener('resize', ()=> {
  if(root) centerOnNode(root, 0.85);
});
</script>
</body>
</html>
