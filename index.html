<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Guha Family Lineage Tree</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root{
    --accent:#1f6fb5;
    --box-bg:#ffffff;
    --box-border:#b08b57;
    --text:#15232f;
    --badge-bg:#0b76d1;
    --badge-color:#ffffff;
    --leaf-bg:#fff0f0;
    --leaf-border:#e03b3b;
  }
  /* Page, header & controls */
  body{ margin:0; font-family: "Segoe UI", Roboto, Arial, sans-serif; background:#ffffff; color:var(--text); overflow:hidden; }
  header{ position:fixed; top:0; left:0; right:0; height:60px; display:flex; align-items:center; justify-content:space-between; padding:8px 16px; background:rgba(255,255,255,0.98); z-index:120; box-shadow:0 4px 12px rgba(16,24,40,0.06); }
  header h1{ margin:0; font-size:18px; color:var(--accent); font-weight:700; }
  #controls{ display:flex; gap:8px; align-items:center; }
  #search{ padding:8px 10px; width:260px; border-radius:8px; border:1px solid rgba(0,0,0,0.12); font-size:13px; }
  #suggestions{ position:absolute; left:16px; top:60px; width:260px; max-height:260px; overflow:auto; background:#fff; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.12); display:none; z-index:220; }
  #suggestions div{ padding:8px 10px; border-bottom:1px solid #f2f4f6; cursor:pointer; }
  #suggestions div:hover{ background:#f0f7ff; }

  /* Info box fixed */
  #infoBox{ position:fixed; top:72px; right:16px; width:300px; background:#fff; padding:10px; border-radius:10px; box-shadow:0 12px 30px rgba(16,24,40,0.06); z-index:220; font-size:13px; }
  #infoBox button{ margin-left:8px; padding:6px 8px; border-radius:8px; border:0; background:#eef6ff; color:var(--accent); cursor:pointer; }

  /* Toolbar for extra buttons */
  #toolbar{ position:fixed; top:72px; left:16px; z-index:220; display:flex; gap:8px; align-items:center; }
  .tool-btn{ background:#fff; border:1px solid #e6eef7; padding:8px 10px; border-radius:8px; cursor:pointer; box-shadow:0 8px 20px rgba(16,24,40,0.04); font-weight:600; color:var(--accent); }

  /* svg wrapper */
  #svgwrap{ position:absolute; top:120px; left:0; right:0; bottom:48px; background:transparent; overflow:hidden; }
  svg{ width:100%; height:100%; display:block; }

  /* node/link visuals */
  .link{ fill:none; stroke:#d6d6d6; stroke-width:2; }
  .node text{ font-size:13px; fill:var(--text); pointer-events:none; }
  .node rect{ fill:var(--box-bg); stroke:var(--box-border); stroke-width:1.2px; rx:10; ry:10; }
  .node rect.leaf{ fill:var(--leaf-bg); stroke:var(--leaf-border); stroke-width:1.8px; }
  .badge{ fill:var(--badge-bg); }
  .badge-text{ fill:var(--badge-color); font-size:11px; font-weight:700; text-anchor:middle; dominant-baseline:central; pointer-events:none; }
  .leaf-dot{ fill:var(--leaf-border); }

  .highlight rect{ stroke:#ff8a65; stroke-width:2.6px; filter: drop-shadow(0 8px 18px rgba(255,134,94,0.12)); }
  .faded{ opacity:0.18; transition:opacity 300ms ease; }

  .gen-label{ font-size:12px; fill:#5b6b78; pointer-events:none; }

  image.photo{ width:56px; height:56px; }

  footer{ position:fixed; bottom:0; left:0; right:0; text-align:center; padding:8px; background:rgba(255,255,255,0.95); z-index:120; border-top:1px solid #eef2f6; }

  /* transitions for smoothness */
  .node { transition: transform 450ms cubic-bezier(.22,.9,.31,1); }
  .link { transition: stroke-dashoffset 450ms cubic-bezier(.22,.9,.31,1); }

  @media (max-width:800px){ #search{ width:160px; } #infoBox{ display:none; } #toolbar{ left:8px; } }
</style>
</head>
<body>

<header>
  <h1>Guha Family Lineage Tree</h1>
  <div id="controls">
    <input id="search" placeholder="Search name..." autocomplete="off"/>
    <div id="suggestions" role="listbox"></div>
  </div>
</header>

<div id="toolbar" aria-hidden="false">
  <button id="expandAll" class="tool-btn">Expand All</button>
  <button id="collapseAll" class="tool-btn">Collapse All</button>
  <button id="resetView" class="tool-btn">Reset View</button>
  <button id="downloadPng" class="tool-btn">Download PNG</button>
</div>

<div id="infoBox" aria-hidden="false">
  <div style="display:flex;justify-content:space-between;align-items:center;">
    <strong>About this tree</strong>
    <button id="infoClose">Hide</button>
  </div>
  <div style="margin-top:8px;font-size:13px;color:#3b4b58;">
    Click a node to reveal its <em>immediate</em> children. Expanding a branch auto-collapses sibling branches for clarity. Photos shown only when PhotoURL exists.
  </div>
</div>

<div id="svgwrap"><svg></svg></div>

<footer>
  <span id="footerJump" style="cursor:pointer;color:var(--accent);font-weight:700">Jump to Tamal</span>
</footer>

<script>
/* ---------------- CONFIG ---------------- */
const csvPath = "data/family.csv";
const FOOTER_NAME = "Tamal"; // substring match
const PHOTO_SIZE = 56;
/* --------------- SVG & ZOOM -------------- */
const svg = d3.select("svg");
const g = svg.append("g");
const zoom = d3.zoom().scaleExtent([0.25,2.2]).on("zoom", (e)=> g.attr("transform", e.transform));
svg.call(zoom);
const tree = d3.tree().nodeSize([100, 300]);
const duration = 450;

let root = null;
let flat = []; // search list

/* ---------- Load CSV & Build Hierarchy (G2) ---------- */
fetch(csvPath).then(r => {
  if(!r.ok) throw new Error("Failed to fetch " + csvPath + " (" + r.status + ")");
  return r.text();
}).then(txt => {
  const rows = d3.csvParse(txt);
  if(!rows || !rows.length) throw new Error("CSV empty");
  buildHierarchyFromRows(rows);
}).catch(err => {
  console.error(err);
  alert("Error loading data/family.csv. Check path and file. See console.");
});

/* Build hierarchy using ParentID (single parent) and auto-generate generation numbers (G2) */
function buildHierarchyFromRows(rows){
  const map = {};
  rows.forEach(r => {
    const ID = (r.ID||r.id||"").toString().trim();
    map[ID] = { ...r, ID, children: [] };
  });
  let rootCandidates = [];
  rows.forEach(r => {
    const ID = (r.ID||r.id||"").toString().trim();
    const P = (r.ParentID||r.parentid||"").toString().trim();
    if(P && map[P]) map[P].children.push(map[ID]);
    else rootCandidates.push(map[ID]);
  });
  // pick first candidate as root
  const rootObj = rootCandidates[0] || map[rows[0].ID];
  if(!rootObj){ alert("No root found in CSV"); return; }

  root = d3.hierarchy(rootObj, d => d.children && d.children.length ? d.children : null);

  // auto-calc depths / op gen numbers (G2)
  root.each(d => { d.data._gen = d.depth + 1; });

  // compute descendant counts
  computeDesc(root);

  // STARTUP S2: show Gen1 & Gen2 only => collapse nodes with depth >1
  root.each(d => {
    if(d.depth > 1){
      if(d.children){ d._children = d.children; d._children.forEach(collapse); d.children = null; }
    }
  });

  // build flat list for search
  flat = []; root.each(d => flat.push({ id: d.data.ID, name: d.data.Name, node: d }));

  // initial render
  update(root);

  // auto-center root
  setTimeout(()=> centerOnNode(root, 0.95), 300);
}

/* compute descendant counts */
function computeDesc(node){
  let total = 0;
  const iterate = ch => {
    let t = 0;
    if(ch.children) ch.children.forEach(c => { iterate(c); t += 1 + (c.data._descCount||0); });
    if(ch._children) ch._children.forEach(c => { iterate(c); t += 1 + (c.data._descCount||0); });
    ch.data._descCount = t;
  };
  if(node) iterate(node);
}

/* collapse helper */
function collapse(d){
  if(d.children){ d._children = d.children; d._children.forEach(collapse); d.children = null; }
}

/* expand one node and collapse siblings (E2) */
function expandNodeKeepSiblingsCollapsed(target){
  if(!target) return;
  // auto-collapse siblings: find parent and collapse children except target
  const parent = target.parent;
  if(parent && parent.children){
    parent.children.forEach(sib => {
      if(sib !== target){
        // move to _children (collapse) recursively
        collapse(sib);
      }
    });
  }
  // expand target (toggle)
  if(target._children){ target.children = target._children; target._children = null; } // expand
  // update counts and render
  computeDesc(root);
  update(target);
}

/* update/render */
function update(source){
  const treeData = tree(root);
  const nodes = treeData.descendants();
  const links = treeData.links();
  nodes.forEach(d => d.y = d.depth * 300);

  // LINKS
  const link = g.selectAll("path.link").data(links, d => d.target.data.ID);
  const linkEnter = link.enter().insert("path", "g").attr("class","link")
    .attr("d", d => {
      const o = { x: source.x0 || source.x, y: source.y0 || source.y };
      return diagonal(o,o);
    });
  linkEnter.merge(link).transition().duration(duration).attr("d", d => diagonal(d.source, d.target));
  link.exit().transition().duration(duration).remove();

  // NODES
  const node = g.selectAll("g.node").data(nodes, d => d.data.ID);

  // ENTER
  const nodeEnter = node.enter().append("g")
    .attr("class","node")
    .attr("transform", d => `translate(${source.y0 || source.y || 0},${source.x0 || source.x || 0})`)
    .on("click", function(event,d){
      event.stopPropagation();
      // E2 behaviour: expand this node, collapse siblings
      expandNodeKeepSiblingsCollapsed(d);
      // center this node a bit
      centerOnNode(d, 1.0);
    });

  // add text for measurement & wrapping
  nodeEnter.append("text").attr("class","label").attr("text-anchor","middle").attr("dy","0")
    .text(d => d.data.Name)
    .each(function(d){
      const text = d3.select(this);
      const words = d.data.Name.split(/\s+/);
      text.text(null);
      let line = [], lineNumber = 0;
      const maxW = 160;
      let tspan = text.append("tspan").attr("x",0).attr("y",0).attr("dy","0em");
      words.forEach(w => {
        line.push(w);
        tspan.text(line.join(" "));
        if(tspan.node().getComputedTextLength() > maxW){
          line.pop();
          tspan.text(line.join(" "));
          line = [w];
          tspan = text.append("tspan").attr("x",0).attr("y",0).attr("dy",++lineNumber * 1.1 + "em").text(w);
        }
      });
    });

  // after text created, measure and add rect, images, badges, gen label, leaf dot
  nodeEnter.each(function(d){
    const nodeG = d3.select(this);
    const textEl = nodeG.select("text").node();
    const bbox = textEl.getBBox();
    const padX = 12, padY = 8;
    const hasPhoto = !!(d.data.PhotoURL && d.data.PhotoURL.trim());
    const photoSpace = hasPhoto ? (PHOTO_SIZE + 8) : 0;
    const rectW = Math.max(90, bbox.width + padX*2);
    const rectH = bbox.height + padY*2 + photoSpace;
    d._rectW = rectW; d._rectH = rectH;

    // rect
    const rect = nodeG.insert("rect", "text")
      .attr("x", -rectW/2).attr("y", -rectH/2).attr("width", rectW).attr("height", rectH)
      .attr("rx",10).attr("ry",10)
      .attr("class", () => ( !(d.children || d._children) ? "leafRect" : "") )
      .style("fill", () => ( !(d.children || d._children) ? "var(--leaf-bg)" : "var(--box-bg)" ))
      .style("stroke", () => ( !(d.children || d._children) ? "var(--leaf-border)" : "var(--box-border)" ))
      .style("stroke-width", () => ( !(d.children || d._children) ? 1.6 : 1.2 ));

    // photo (PH1) - only when PhotoURL exists
    if(hasPhoto){
      const photoX = 0;
      const photoY = -rectH/2 + PHOTO_SIZE/2 + 8;
      const clipId = "clip_" + (d.data.ID||Math.random()).replace(/[^a-zA-Z0-9_]/g,"_");
      nodeG.append("clipPath").attr("id", clipId).append("circle").attr("cx", photoX).attr("cy", photoY).attr("r", PHOTO_SIZE/2);
      nodeG.append("image")
        .attr("xlink:href", d.data.PhotoURL)
        .attr("x", photoX - PHOTO_SIZE/2)
        .attr("y", photoY - PHOTO_SIZE/2)
        .attr("width", PHOTO_SIZE).attr("height", PHOTO_SIZE)
        .attr("class","photo")
        .attr("clip-path", `url(#${clipId})`)
        .style("stroke", "#ddd").style("stroke-width","1px");
      nodeG.select("text").attr("y", -rectH/2 + PHOTO_SIZE + padY + 6);
    } else {
      nodeG.select("text").attr("y", -rectH/2 + padY + 2);
    }

    // descendant badge
    const desc = d.data._descCount || 0;
    if(desc > 0){
      const bx = rectW/2 - 14;
      const by = -rectH/2 + 14;
      nodeG.append("circle").attr("class","badge").attr("cx", bx).attr("cy", by).attr("r", 12);
      nodeG.append("text").attr("class","badge-text").attr("x", bx).attr("y", by).text(desc);
    }

    // generation label
    nodeG.append("text").attr("class","gen-label").attr("y", rectH/2 + 14).attr("text-anchor","middle").text(`Gen ${d.depth+1}`);

    // leaf dot
    const isLeaf = !(d.children || d._children);
    if(isLeaf){
      const dx = rectW/2 + 12;
      nodeG.append("circle").attr("class","leaf-dot").attr("cx", dx).attr("cy", 0).attr("r",6);
      // add leaf style to rect
      nodeG.select("rect").classed("leaf", true);
    }
  });

  // UPDATE + TRANSITION
  const nodeUpdate = nodeEnter.merge(node);
  nodeUpdate.transition().duration(duration).attr("transform", d => `translate(${d.y},${d.x})`);

  // EXIT
  const nodeExit = node.exit().transition().duration(duration).attr("transform", d => `translate(${source.y},${source.x})`).remove();

  // save positions
  nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
}

/* diagonal path generator */
function diagonal(s,d){
  return `M ${s.y} ${s.x}
          C ${(s.y + d.y)/2} ${s.x},
            ${(s.y + d.y)/2} ${d.x},
            ${d.y} ${d.x}`;
}

/* --------- SEARCH / SUGGESTIONS --------- */
const search = document.getElementById('search');
const sugg = document.getElementById('suggestions');
let suggVisible = false;
search.addEventListener('input', e => {
  const q = e.target.value.trim().toLowerCase();
  if(!q){ sugg.style.display='none'; suggVisible=false; return; }
  const results = flat.filter(x => x.name.toLowerCase().includes(q));
  sugg.innerHTML = '';
  results.slice(0,30).forEach(r => {
    const div = document.createElement('div'); div.textContent = r.name;
    div.onclick = () => { selectNodeFromSearch(r); sugg.style.display='none'; suggVisible=false; search.value=''; };
    sugg.appendChild(div);
  });
  if(results.length) { sugg.style.display='block'; suggVisible=true; } else { sugg.style.display='none'; suggVisible=false; }
});

window.addEventListener('click', e => { if(!document.getElementById('controls')?.contains(e.target) && suggVisible){ sugg.style.display='none'; suggVisible=false; } });

function selectNodeFromSearch(item){
  expandPathTo(item.node);
  centerOnNode(item.node, 1.0);
  highlightNode(item.node);
}

/* expand path to node (make visible) */
function expandPathTo(target){
  let cur = target.parent; const toOpen = [];
  while(cur){ toOpen.push(cur); cur = cur.parent; }
  toOpen.reverse().forEach(n => { if(n._children){ n.children = n._children; n._children = null; } });
  computeDesc(root);
  update(root);
}

/* center and zoom */
function centerOnNode(node, preferScale=1){
  const vb = svg.node().getBoundingClientRect();
  const vw = vb.width, vh = vb.height;
  const k = Math.max(0.45, Math.min(1.4, preferScale));
  const tx = vw/2 - node.y * k;
  const ty = vh/2 - node.x * k;
  svg.transition().duration(700).call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(k));
}

/* highlight */
function highlightNode(d){
  g.selectAll("g.node").classed("highlight", false).classed("faded", false);
  g.selectAll("g.node").filter(n => n.data.ID !== d.data.ID).classed("faded", true);
  g.selectAll("g.node").filter(n => n.data.ID === d.data.ID).classed("highlight", true);
  clearTimeout(window._hlTimer);
  window._hlTimer = setTimeout(()=> { g.selectAll("g.node").classed("highlight", false).classed("faded", false); }, 7000);
}

/* -------- Toolbar actions: Expand All / Collapse All / Reset / Download PNG -------- */
document.getElementById('expandAll').addEventListener('click', () => {
  if(!root) return;
  root.each(d => { if(d._children){ d.children = d._children; d._children = null; } });
  computeDesc(root); update(root); centerOnNode(root, 0.8);
});
document.getElementById('collapseAll').addEventListener('click', () => {
  if(!root) return;
  root.each(d => { if(d.children && d.depth > 1){ d._children = d.children; d._children.forEach(collapse); d.children = null; } });
  computeDesc(root); update(root); centerOnNode(root, 0.85);
});
document.getElementById('resetView').addEventListener('click', () => { if(root) centerOnNode(root, 0.95); });

/* download PNG - note: remote images can taint canvas making download fail */
document.getElementById('downloadPng').addEventListener('click', async () => {
  try {
    const svgNode = svg.node();
    const serializer = new XMLSerializer();
    const svgString = serializer.serializeToString(svgNode);
    const blob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(blob);

    const img = new Image();
    img.onload = () => {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = svgNode.clientWidth;
        canvas.height = svgNode.clientHeight;
        const ctx = canvas.getContext('2d');
        // white background
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
        // try toDataURL
        const dataUrl = canvas.toDataURL('image/png');
        const a = document.createElement('a'); a.href = dataUrl; a.download = 'family-tree.png'; document.body.appendChild(a); a.click(); a.remove();
      } catch(e){
        alert('Download failed â€” likely due to external images (CORS) on the tree. Try removing external images or host them on same origin.');
        console.error(e);
      }
    };
    img.onerror = (e) => {
      URL.revokeObjectURL(url);
      alert('Could not render SVG to image for download (possible CORS issue with images).');
      console.error(e);
    };
    img.src = url;
  } catch(err){
    alert('Failed to create PNG: ' + err.message);
    console.error(err);
  }
});

/* Footer jump-to */
document.getElementById('footerJump').addEventListener('click', () => {
  if(!flat.length){ alert('Data not ready'); return; }
  const found = flat.find(x => x.name.toLowerCase().includes(FOOTER_NAME.toLowerCase()));
  if(!found){ alert("Could not find '" + FOOTER_NAME + "' in the data"); return; }
  expandPathTo(found.node); centerOnNode(found.node,1.0); highlightNode(found.node);
});

/* info close */
document.getElementById('infoClose').addEventListener('click', ()=> document.getElementById('infoBox').style.display='none' );

/* keep centered on resize */
window.addEventListener('resize', ()=> { if(root) centerOnNode(root, 0.85); });

</script>
</body>
</html>
